<!DOCTYPE html>
<html>
<head>
    <title>Canvas Point</title>
</head>
<body>

    <script>
		// Coordinate of a vertex in camera view in metres
		var coords = [30,20,1];
		// Frustum size in metres(x,y)
		var frustumSize = [600,300];
		var projectedCoords = [((coords[0]/frustumSize[0])*600),((coords[1]/frustumSize[1])*300)]
        // Function to draw a 2x2 pixel black point on the canvas
        function drawPoint(ctx, x, y) {
            ctx.fillStyle = "black"; // Set the color to black
            ctx.fillRect(x, y, 1, 1); // Fill a 2x2 pixel rectangle at (x, y)
        }


    </script>
	
	<h2>Perspective projection:</h2>
    <canvas id="myCanvasPersp" width="600" height="300" style="border: 1px solid #ccc;"></canvas>
    <script>
	    // Get the canvas element and its context
        const canvasPersp = document.getElementById('myCanvasPersp');
        const ctxPersp = canvasPersp.getContext('2d');
	
		// Frustum size in metres(x,y)
		var screenSize = [600,300];
		// Aspect ratio
		const aspectRatio = 600/300;
		// Field of view
		const FOV_deg = 30;
		const FOV = FOV_deg*(3.14/180);
		
		// Blueprint for a 3D model object
		class object3D{
			constructor(vertexPoints, centreVertex){
				this.points = vertexPoints;
				this.centre = centreVertex;
			}
			
			// Model to world vertex coordinates transformation. Inputs are the objects position, rotation and scale coordinates
			function calculateWorldCoords([x_p,y_p,z_p],[x_r,y_r,z_r],[x_s,y_s,z_s]){			
				
				var worldCoords = this.points;
				
				// Positional transformation
				worldCoords.forEach((coord)=>{
					coord[0] += x_p;
					coord[1] += y_p;
					coord[2] += z_p;
				});
				

				return worldCoords;
			}
			
			// Calculate camera coordinates of one point		
			function calculateCameraCoords([x,y,z]){			
				var x_s = (x)/(z*aspectRatio*FOV);
				var y_s = (y)/(z*FOV);
				var projectedCoordsPersp = [(((x_s+1)/2)*screenSize[0]),(((1-y_s)/2)*screenSize[1])];
				console.log([x,y,z]);
				return projectedCoordsPersp;
			}
			
			// Calculate all coordinates of an object
			function calculateAllCoords(coordsPersp2){
				var i = 0;
				var finalCoords=[];
				for(let coord of coordsPersp2){
					finalCoords[i] = this.calculateCameraCoords(coord);
					i++;
				}
				
				return finalCoords;
			}
		
		}
		var object1 = new object3D([[30,20,100],[30,5,100],[30,5,85],[30,20,85],[15,20,100],[15,5,100],[15,20,85],[30,20,85],[15,5,85]],[30,20,100],[0,0,0]);
		
		// Coordinate of a vertex in model view
		var coordsPersp = object1.points;
				

		
		function drawPoints(coordsPersp2){
			var finalCoords = calculateAllCoords(coordsPersp2);
			
			// Draw the points
			for(let coord of finalCoords){
				drawPoint(ctxPersp, coord[0], coord[1]);
			}
			/*
			// Draw lines between vertices
			var slope = (finalCoords[2][1]-finalCoords[0][1])/(finalCoords[2][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[2][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			
			slope = (finalCoords[3][1]-finalCoords[0][1])/(finalCoords[3][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[3][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			*/
		}
		function drawFrame(){
			ctxPersp.clearRect(0, 0, canvasPersp.width, canvasPersp.height);
			coordsPersp = rotate3DPointsAroundCenter(coordsPersp, 0.1,0.1,0.1);
			
			drawPoints(coordsPersp);
		}
		//setInterval(drawFrame, 200);
		drawFrame();
		
		// Fill the polygon
		
		
    </script>
	
</body>
</html>
