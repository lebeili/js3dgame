<!DOCTYPE html>
<html>
<head>
    <title>Canvas Point</title>
</head>
<body>

    <script>
		// Coordinate of a vertex in camera view in metres
		var coords = [30,20,1];
		// Frustum size in metres(x,y)
		var frustumSize = [600,300];
		var projectedCoords = [((coords[0]/frustumSize[0])*600),((coords[1]/frustumSize[1])*300)]
        // Function to draw a 2x2 pixel black point on the canvas
        function drawPoint(ctx, x, y) {
            ctx.fillStyle = "black"; // Set the color to black
            ctx.fillRect(x, y, 1, 1); // Fill a 2x2 pixel rectangle at (x, y)
        }


    </script>
	
	<h2>Perspective projection:</h2>
    <canvas id="myCanvasPersp" width="600" height="300" style="border: 1px solid #ccc;"></canvas>
    <script>
	    // Get the canvas element and its context
        const canvasPersp = document.getElementById('myCanvasPersp');
        const ctxPersp = canvasPersp.getContext('2d');
	
		// Frustum size in metres(x,y)
		var screenSize = [600,300];
		// Aspect ratio
		const aspectRatio = 600/300;
		// Field of view
		const FOV_deg = 180;
		const FOV = FOV_deg*(3.14/180);
		
		// Blueprint for a 3D model object
		class object3D{
			constructor(vertexPoints){
				this.points = vertexPoints;
			}
			
			// Model to world vertex coordinates transformation. Inputs are the objects position, rotation and scale coordinates
			calculateWorldCoords([x_p,y_p,z_p],[x_r,y_r,z_r],[x_s,y_s,z_s]){			
				
				let worldCoordsLocal = JSON.parse(JSON.stringify(this.points));
				//console.log(this.points);
				// Positional transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] += x_p;
					coord[1] += y_p;
					coord[2] += z_p;
					
				});

				/*// Rotational transformation
				worldCoords.forEach((coord)=>{
					coord[0] += x_p;
					coord[1] += y_p;
					coord[2] += z_p;
				});*/
				
				// Scale transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] *= x_s;
					coord[1] *= y_s;
					coord[2] *= z_s;
				});
				//console.log(worldCoordsLocal);
				return worldCoordsLocal;
			}
			
			// Viewing transformation. Inputs are the cameras positional and rotational world coordinates as well as the world coordinates of the object.
			calculateCameraCoords([x_p,y_p,z_p],[x_r,y_r,z_r],worldCoords){
				let worldCoordsLocal = JSON.parse(JSON.stringify(worldCoords));
				// Positional transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] -= x_p;
					coord[1] -= y_p;
					coord[2] -= z_p;
				});
				// Rotational transformation
				var R_inverse = [
				  [1, 0, 0],
				  [0, Math.cos(x_r), -Math.sin(x_r)],
				  [0, Math.sin(x_r), Math.cos(x_r)]
				];
				
				worldCoordsLocal.forEach((coord)=>{
					for (let i = 0; i < 3; i++) {
					  coord[i] = R_inverse[i][0] * coord[0] + R_inverse[i][1] * coord[1] + R_inverse[i][2] * coord[2];
					}
				});
				let cameraCoords = worldCoordsLocal;
				//console.log(worldCoordsLocal);
				return cameraCoords;
			}
			
			// Projection transformation. The input is the coordinates after viewing transformation.
			calculateProjectedCoords(cameraCoords){
				var projectedCoords = [];
				var cameraCoordsLocal = JSON.parse(JSON.stringify(cameraCoords));
				var x_tmp;
				var y_tmp;
				var projectedCoordsPersp_tmp;
				cameraCoordsLocal.forEach((coord)=>{
					x_tmp = (coord[0])/(coord[1]*aspectRatio*FOV);
					y_tmp = (coord[1])/(coord[2]*FOV);
					projectedCoordsPersp_tmp = [(((x_tmp+1)/2)*screenSize[0]),(((1-y_tmp)/2)*screenSize[1])];
					projectedCoords.push(projectedCoordsPersp_tmp);
				});			

				//console.log([x,y,z]);
				return projectedCoords;
			}
		
		}
		var object1 = new object3D([[0,0,0],[0,0,60],[0,60,60],[0,60,0],[60,0,60],[60,0,0],[60,60,60],[60,60,0]]);
				

		
		function drawPoints(objectV,camPos,camRot){
			var finalCoordsWorld = objectV.calculateWorldCoords([1,1,1],[0,0,0],[1,1,1]);
			var finalCoordsCamera = objectV.calculateCameraCoords(camPos,camRot,finalCoordsWorld);
			var finalCoordsProj = objectV.calculateProjectedCoords(finalCoordsCamera);
			// Draw the points
			for(let coord of finalCoordsProj){
				drawPoint(ctxPersp, coord[0], coord[1]);
			}
			//console.log(finalCoordsProj);
			/*
			// Draw lines between vertices
			var slope = (finalCoords[2][1]-finalCoords[0][1])/(finalCoords[2][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[2][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			
			slope = (finalCoords[3][1]-finalCoords[0][1])/(finalCoords[3][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[3][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			*/
		}
		function drawFrame(camPos,camRot){
			ctxPersp.clearRect(0, 0, canvasPersp.width, canvasPersp.height);
//			coordsPersp = rotate3DPointsAroundCenter(coordsPersp, 0.1,0.1,0.1);
			
			drawPoints(object1,camPos,camRot);
			//console.log(camPos);
		}
		var cameraPos = [0,0,0];
		var cameraRot = [0,0,0];
		setInterval(()=>{
		cameraPos[0] -= 0.1;
		cameraPos[1] -= 0.1;
		cameraPos[2] -= 0.1;
		/*cameraRot[0] += 0.1;
		cameraRot[1] += 0.1;
		cameraRot[2] += 0.1;*/
		drawFrame(cameraPos,cameraRot);}, 100);
		drawFrame(cameraPos,cameraRot);
		document.addEventListener("click",()=>{
		//cameraPos[0] += 0.1;
		//cameraPos[1] += 0.1;
		//cameraPos[2] += 0.1;
		cameraRot[0] += 0.1;
		cameraRot[1] += 0.1;
		cameraRot[2] += 0.1;
		drawFrame(cameraPos,cameraRot);});
		// Fill the polygon
		
		
    </script>
	
</body>
</html>
