<!DOCTYPE html>
<html>
<head>
    <title>Canvas Point</title>
</head>
<body>

    <script>
		// Coordinate of a vertex in camera view in metres
		var coords = [30,20,1];
		// Frustum size in metres(x,y)
		var frustumSize = [600,300];
		var projectedCoords = [((coords[0]/frustumSize[0])*600),((coords[1]/frustumSize[1])*300)]
        // Function to draw a 2x2 pixel black point on the canvas
        function drawPoint(ctx, x, y) {
            ctx.fillStyle = "black"; // Set the color to black
            ctx.fillRect(x, y, 1, 1); // Fill a 2x2 pixel rectangle at (x, y)
        }


    </script>
	
	<h2>Perspective projection:</h2>
    <canvas id="myCanvasPersp" width="600" height="300" style="border: 1px solid #ccc;"></canvas>
    <script>
	    // Get the canvas element and its context
        const canvasPersp = document.getElementById('myCanvasPersp');
        const ctxPersp = canvasPersp.getContext('2d');
	
		// Frustum size in metres(x,y)
		var screenSize = [600,300];
		// Aspect ratio
		const aspectRatio = 600/300;
		// Field of view
		const FOV_deg = 30;
		const FOV = FOV_deg*(3.14/180);
		
		// Blueprint for a 3D model object
		class object3D{
			constructor(vertexPoints, centreVertex){
				this.points = vertexPoints;
				this.centre = centreVertex;
			}
			
		}
		var object1 = new object3D([[30,20,100],[30,5,100],[30,5,85],[30,20,85],[15,20,100],[15,5,100],[15,20,85],[30,20,85],[15,5,85]],[30,20,100]);
		
		// Coordinate of a vertex in model view
		var coordsPersp = [[30,20,100],[30,5,100],[30,5,85],[30,20,85],[15,20,100],[15,5,100],[15,20,85],[30,20,85],[15,5,85]];
		

		function multiplyMatrixByConstant(matrix, constant) {
			const result = [];

			for (let i = 0; i < matrix.length; i++) {
				const row = [];
				for (let j = 0; j < matrix[i].length; j++) {
					row.push(matrix[i][j] * constant);
				}
				result.push(row);
			}

			return result;
		}
		function rotate3DPoints(points, angleX, angleY, angleZ) {
			const result = [];

			const cosX = Math.cos(angleX);
			const sinX = Math.sin(angleX);
			const cosY = Math.cos(angleY);
			const sinY = Math.sin(angleY);
			const cosZ = Math.cos(angleZ);
			const sinZ = Math.sin(angleZ);

			for (let i = 0; i < points.length; i++) {
				const x = points[i][0];
				const y = points[i][1];
				const z = points[i][2];

				const rotatedX = x * cosY * cosZ - y * cosY * sinZ + z * sinY;
				const rotatedY = x * (sinX * sinY * cosZ + cosX * sinZ) + y * (sinX * sinY * sinZ - cosX * cosZ) - z * sinX * cosY;
				const rotatedZ = x * (cosX * sinY * cosZ - sinX * sinZ) + y * (cosX * sinY * sinZ + sinX * cosZ) + z * cosX * cosY;

				result.push([rotatedX, rotatedY, rotatedZ]);
			}

			return result;
		}
		function findCenter(points) {
			const center = [0, 0, 0];
			for (let i = 0; i < points.length; i++) {
				for (let j = 0; j < 3; j++) {
					center[j] += points[i][j];
				}
			}
			for (let j = 0; j < 3; j++) {
				center[j] /= points.length;
			}
			return center;
		}

		function rotate3DPointsAroundCenter(points, angleX, angleY, angleZ) {
			const center = findCenter(points);

			const translatedPoints = points.map(point => [
				point[0] - center[0],
				point[1] - center[1],
				point[2] - center[2]
			]);

			const rotatedPoints = rotate3DPoints(translatedPoints, angleX, angleY, angleZ);

			const finalPoints = rotatedPoints.map(point => [
				point[0] + center[0],
				point[1] + center[1],
				point[2] + center[2]
			]);

			return finalPoints;
		}
		
		
		
		
		function calculateCoords([x,y,z]){			
			var x_s = (x)/(z*aspectRatio*FOV);
			var y_s = (y)/(z*FOV);
			var projectedCoordsPersp = [(((x_s+1)/2)*screenSize[0]),(((1-y_s)/2)*screenSize[1])];
			console.log([x,y,z]);
			return projectedCoordsPersp;
		}
		
		function calculateAllCoords(coordsPersp2){
			var i = 0;
			var finalCoords=[];
			for(let coord of coordsPersp2){
				finalCoords[i] = calculateCoords(coord);
				i++;
			}
			
			return finalCoords;
		}
		
		function drawPoints(coordsPersp2){
			var finalCoords = calculateAllCoords(coordsPersp2);
			
			// Draw the points
			for(let coord of finalCoords){
				drawPoint(ctxPersp, coord[0], coord[1]);
			}
			/*
			// Draw lines between vertices
			var slope = (finalCoords[2][1]-finalCoords[0][1])/(finalCoords[2][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[2][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			
			slope = (finalCoords[3][1]-finalCoords[0][1])/(finalCoords[3][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[3][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			*/
		}
		function drawFrame(){
			ctxPersp.clearRect(0, 0, canvasPersp.width, canvasPersp.height);
			coordsPersp = rotate3DPointsAroundCenter(coordsPersp, 0.1,0.1,0.1);
			
			drawPoints(coordsPersp);
		}
		//setInterval(drawFrame, 200);
		drawFrame();
		
		// Fill the polygon
		
		
    </script>
	
</body>
</html>
