<!DOCTYPE html>
<html>
<head>
    <title>Canvas Point</title>
</head>
<body>

    <script>
		// Coordinate of a vertex in camera view in metres
		var coords = [30,20,1];
		// Frustum size in metres(x,y)
		var frustumSize = [600,300];
		var projectedCoords = [((coords[0]/frustumSize[0])*600),((coords[1]/frustumSize[1])*300)]
        // Function to draw a 2x2 pixel black point on the canvas
        function drawPoint(ctx, x, y,x_next, y_next) {
            ctx.fillStyle = "black"; // Set the color to black
            ctx.fillRect(x, y, 1, 1); // Fill a 2x2 pixel rectangle at (x, y)
			ctx.beginPath();
			ctx.moveTo(x, y);
			ctx.lineTo(x_next, y_next);
			ctx.stroke();
        }


    </script>
	
	<h2>Perspective projection:</h2>
    <canvas id="myCanvasPersp" width="600" height="300" style="border: 1px solid #ccc;"></canvas>
    <script>
	    // Get the canvas element and its context
        const canvasPersp = document.getElementById('myCanvasPersp');
        const ctxPersp = canvasPersp.getContext('2d');
		ctxPersp.strokeStyle = 'blue';
		ctxPersp.lineWidth = 1;
		// Frustum size in metres(x,y)
		var screenSize = [600,300];
		// Aspect ratio
		const aspectRatio = 600/300;
		// Field of view
		const FOV_deg = 180;
		const FOV = FOV_deg*(3.14/180);
		
		
		function rotateX(theta, point) {
		  var [ x, y, z ] = point;
		  var cosTheta = Math.cos(theta);
		  var sinTheta = Math.sin(theta);
		  
		  var newY = y * cosTheta - z * sinTheta;
		  var newZ = y * sinTheta + z * cosTheta;
		  
		  return [ x, newY, newZ ];
		}
				
		// Blueprint for a 3D model object
		class object3D{
			constructor(vertexPoints){
				this.points = vertexPoints;
			}
			
			// Model to world vertex coordinates transformation. Inputs are the objects position, rotation and scale coordinates
			calculateWorldCoords([x_p,y_p,z_p],[x_r,y_r,z_r],[x_s,y_s,z_s]){			
				
				let worldCoordsLocal = JSON.parse(JSON.stringify(this.points));
				//console.log(this.points);
				// Positional transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] += x_p;
					coord[1] += y_p;
					coord[2] += z_p;
					
				});

				// Rotational transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] = rotateX(x_r, coord)[0];
					coord[1] = rotateX(x_r, coord)[1];
					coord[2] = rotateX(x_r, coord)[2];
					
				});
				console.log(worldCoordsLocal);
				// Scale transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] *= x_s;
					coord[1] *= y_s;
					coord[2] *= z_s;
				});
				//console.log(worldCoordsLocal);
				return worldCoordsLocal;
			}
			
			// Viewing transformation. Inputs are the cameras positional and rotational world coordinates as well as the world coordinates of the object.
			calculateCameraCoords([x_p,y_p,z_p],[x_r,y_r,z_r],worldCoords){
				let worldCoordsLocal = JSON.parse(JSON.stringify(worldCoords));
				// Positional transformation
				worldCoordsLocal.forEach((coord)=>{
					coord[0] -= x_p;
					coord[1] -= y_p;
					coord[2] -= z_p;
				});
				// Rotational transformation
				var R_inverse = [
				  [1, 0, 0],
				  [0, Math.cos(x_r), -Math.sin(x_r)],
				  [0, Math.sin(x_r), Math.cos(x_r)]
				];
				
				worldCoordsLocal.forEach((coord)=>{
					for (let i = 0; i < 3; i++) {
					  coord[i] = R_inverse[i][0] * coord[0] + R_inverse[i][1] * coord[1] + R_inverse[i][2] * coord[2];
					}
				});
				let cameraCoords = worldCoordsLocal;
				//console.log(worldCoordsLocal);
				return cameraCoords;
			}
			
			// Projection transformation. The input is the coordinates after viewing transformation.
			calculateProjectedCoords(cameraCoords){
				var projectedCoords = [];
				var cameraCoordsLocal = JSON.parse(JSON.stringify(cameraCoords));
				var x_tmp;
				var y_tmp;
				var projectedCoordsPersp_tmp;
				cameraCoordsLocal.forEach((coord)=>{
					x_tmp = (coord[0])/(coord[1]*aspectRatio*FOV);
					y_tmp = (coord[1])/(coord[2]*FOV);
					projectedCoordsPersp_tmp = [(((x_tmp+1)/2)*screenSize[0]),(((1-y_tmp)/2)*screenSize[1])];
					projectedCoords.push(projectedCoordsPersp_tmp);
				});			

				//console.log([x,y,z]);
				return projectedCoords;
			}
		
		}
		//var object1 = new object3D([[0,0,0],[0,0,10],[0,10,10],[0,10,0],[10,10,0],[10,10,10],[10,0,10],[10,0,0]]);
			var object1 = new object3D([[0,0,0],[0,0,10],[0,10,10]]);	

		
		function drawPoints(objectV,camPos,camRot,x_rot){
			var finalCoordsWorld = objectV.calculateWorldCoords([1,1,1],[x_rot,0,0],[1,1,1]);
			var finalCoordsCamera = objectV.calculateCameraCoords(camPos,camRot,finalCoordsWorld);
			var finalCoordsProj = objectV.calculateProjectedCoords(finalCoordsCamera);
			// Draw the points
			for(let i = 0; i<finalCoordsProj.length;i++){
				if(i+1 != finalCoordsProj.length){
					drawPoint(ctxPersp, finalCoordsProj[i][0], finalCoordsProj[i][1], finalCoordsProj[i+1][0], finalCoordsProj[i+1][1]);
				}else{
					drawPoint(ctxPersp, finalCoordsProj[i][0], finalCoordsProj[i][1], finalCoordsProj[0][0], finalCoordsProj[0][1]);
				}
			}
			//console.log(finalCoordsProj);
			/*
			// Draw lines between vertices
			var slope = (finalCoords[2][1]-finalCoords[0][1])/(finalCoords[2][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[2][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			
			slope = (finalCoords[3][1]-finalCoords[0][1])/(finalCoords[3][0]-finalCoords[0][0]);
			console.log(slope);
			for(let i = finalCoords[0][0];i<=finalCoords[3][0];i++){
				drawPoint(ctxPersp, i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
				//console.log(i, (slope*i)+(finalCoords[0][1]-slope*finalCoords[0][0]));
			}
			*/
		}
		function drawFrame(camPos,camRot,x_rot){
			ctxPersp.clearRect(0, 0, canvasPersp.width, canvasPersp.height);
//			coordsPersp = rotate3DPointsAroundCenter(coordsPersp, 0.1,0.1,0.1);
			
			drawPoints(object1,camPos,camRot,x_rot);
			//console.log(camPos);
		}
		var cameraPos = [60,64,0];
		var cameraRot = [73,0,70];
		var obj_x_rot = 0;
		setInterval(()=>{
		/*cameraPos[0] -= 0.1;
		cameraPos[1] -= 0.1;
		cameraPos[2] -= 0.1;*/
		obj_x_rot+= 0.03;
		/*cameraRot[0] += 0.1;
		cameraRot[1] += 0.1;
		cameraRot[2] += 0.1;*/
		drawFrame(cameraPos,cameraRot,obj_x_rot);}, 20);
		drawFrame(cameraPos,cameraRot,obj_x_rot);
document.addEventListener("keydown", function(event) {
  if (event.key === "ArrowUp") {
		cameraPos[1] += 1;

  } else if (event.key === "ArrowDown") {
cameraPos[1] -= 1;
  } else if (event.key === "ArrowLeft") {
cameraPos[0] += 1;
  } else if (event.key === "ArrowRight") {
cameraPos[0] -= 1;
  }else if (event.key === "w") {
cameraRot[1] -= 0.1;
  } else if (event.key === "s") {
cameraRot[1] += 0.1;
  } else if (event.key === "a") {
cameraRot[0] -= 0.1;
  }else if (event.key === "d") {
cameraRot[0] -= 0.1;
  }
});
		// Fill the polygon
		
		
    </script>
	
</body>
</html>
